import{defineComponent as e,computed as a,h as t,onServerPrefetch as n,toValue as r,getCurrentInstance as s,ref as o,shallowRef as i,toRef as u,nextTick as c,unref as l,createElementBlock as d,provide as p,cloneVNode as m}from"vue";import{Icon as f,getIcon as y,loadIcon as v}from"@iconify/vue";import{getIconCSS as h}from"@iconify/utils/lib/css/icon";import{a as _,e as D,b as g,d as w,f as x,g as b}from"./server.mjs";import"../_/nitro.mjs";import"node:http";import"node:https";import"node:events";import"node:buffer";import"@iconify/utils";import"node:crypto";import"consola";import"node:url";import"ipx";import"node:fs";import"node:path";import"vue-router";import"tailwindcss/colors";import"vue/server-renderer";import"../routes/renderer.mjs";import"vue-bundle-renderer/runtime";import"unhead/server";import"devalue";import"unhead/utils";const P={trailing:!0};function debounce(e,a=25,t={}){if(t={...P,...t},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let n,r,s,o,i=[];const applyFn=(a,n)=>(s=async function(e,a,t){return await e.apply(a,t)}(e,a,n),s.finally(()=>{if(s=null,t.trailing&&o&&!r){const e=applyFn(a,o);return o=null,e}}),s),debounced=function(...e){return t.trailing&&(o=e),s||new Promise(s=>{const u=!r&&t.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const a=t.leading?n:applyFn(this,e);o=null;for(const e of i)e(a);i=[]},a),u?(n=applyFn(this,e),s(n)):i.push(s)})},_clearTimeout=e=>{e&&(clearTimeout(e),r=null)};return debounced.isPending=()=>!!r,debounced.cancel=()=>{_clearTimeout(r),i=[],o=null},debounced.flush=()=>{if(_clearTimeout(r),!o||s)return;const e=o;return o=null,applyFn(this,e)},debounced}async function loadIcon(e,a){if(!e)return null;const t=y(e);if(t)return t;let n;const r=v(e).catch(()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null));return a>0?await Promise.race([r,new Promise(t=>{n=setTimeout(()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()},a)})]).finally(()=>clearTimeout(n)):await r,y(e)}function useResolvedName(e){const t=D().icon,n=(t.collections||[]).sort((e,a)=>a.length-e.length);return a(()=>{const a=e(),r=a.startsWith(t.cssSelectorPrefix)?a.slice(t.cssSelectorPrefix.length):a,s=t.aliases?.[r]||r;if(!s.includes(":")){const e=n.find(e=>s.startsWith(e+"-"));return e?e+":"+s.slice(e.length+1):s}return s})}function resolveCustomizeFn(e,a){if(!1!==e)return!0===e||null===e?a:e}const C="NUXT_ICONS_SERVER_CSS";const z=e({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e){const r=_(),s=D().icon,o=a(()=>e.name?s.cssSelectorPrefix+e.name:""),i=a(()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(o.value));return n(async()=>{{const a=g().icon||{};if(!a?.serverKnownCssClasses?.includes(o.value)){const a=await loadIcon(e.name,s.fetchTimeout).catch(()=>null);if(!a)return null;let t=r.vueApp._context.provides[C];if(t||(t=r.vueApp._context.provides[C]=new Map,r.runWithContext(()=>{w({style:[()=>{let e=Array.from(t.values()).sort().join("");return s.cssLayer&&(e=`@layer ${s.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})})),e.name&&!t.has(e.name)){const n=function(a,t=!0){let n=i.value;s.cssWherePseudo&&(n=`:where(${n})`);const r=h(a,{iconSelector:n,format:"compressed",customise:resolveCustomizeFn(e.customize,s.customize)});return s.cssLayer&&t?`@layer ${s.cssLayer} { ${r} }`:r}(a,!1);t.set(e.name,n)}return null}}}),()=>t("span",{class:["iconify",o.value]})}});e({name:"ServerPlaceholder",render:()=>d("div")});const N=Symbol.for("nuxt:client-only");function useAsyncData(...e){const t="string"==typeof e[e.length-1]?e.pop():void 0;(function(e,a){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof a)return!1;return!0})(e[0],e[1])&&e.unshift(t);let[d,p,m={}]=e;const f=a(()=>r(d));if("string"!=typeof f.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof p)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const y=_();m.server??=!0,m.default??=getDefault,m.getCachedData??=getDefaultCachedData,m.lazy??=!1,m.immediate??=!0,m.deep??=x.deep,m.dedupe??="cancel",m._functionName,y._asyncData[f.value];const v={cause:"initial",dedupe:m.dedupe};y._asyncData[f.value]?._init||(v.cachedData=m.getCachedData(f.value,y,{cause:"initial"}),y._asyncData[f.value]=function(e,t,n,r,s){e.payload._errors[t]??=void 0;const d=r.getCachedData!==getDefaultCachedData,p=n,m=r.deep?o:i,f=void 0!==s,y=e.hook("app:data:refresh",async e=>{e&&!e.includes(t)||await v.execute({cause:"refresh:hook"})}),v={data:m(f?s:r.default()),pending:a(()=>"pending"===v.status.value),error:u(e.payload._errors,t),status:i("idle"),execute:(...a)=>{const[n,s]=a,o=n&&void 0===s&&"object"==typeof n?n:{};if(e._asyncDataPromises[t]){if("defer"===(o.dedupe??r.dedupe))return e._asyncDataPromises[t];e._asyncDataPromises[t].cancelled=!0}{const a="cachedData"in o?o.cachedData:r.getCachedData(t,e,{cause:o.cause??"refresh:manual"});if(void 0!==a)return e.payload.data[t]=v.data.value=a,v.error.value=void 0,v.status.value="success",Promise.resolve(a)}v.status.value="pending";const i=new Promise((a,t)=>{try{a(p(e))}catch(e){t(e)}}).then(async a=>{if(i.cancelled)return e._asyncDataPromises[t];let n=a;r.transform&&(n=await r.transform(a)),r.pick&&(n=function(e,a){const t={};for(const n of a)t[n]=e[n];return t}(n,r.pick)),e.payload.data[t]=n,v.data.value=n,v.error.value=void 0,v.status.value="success"}).catch(a=>{if(i.cancelled)return e._asyncDataPromises[t];v.error.value=b(a),v.data.value=l(r.default()),v.status.value="error"}).finally(()=>{i.cancelled||delete e._asyncDataPromises[t]});return e._asyncDataPromises[t]=i,e._asyncDataPromises[t]},_execute:debounce((...e)=>v.execute(...e),0,{leading:!0}),_default:r.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{y(),e._asyncData[t]?._init&&(e._asyncData[t]._init=!1),d||c(()=>{e._asyncData[t]?._init||(clearNuxtDataByKey(e,t),v.execute=()=>Promise.resolve())})}};return v}(y,f.value,p,m,v.cachedData));y._asyncData[f.value]._deps++;if(!1!==m.server&&y.payload.serverRendered&&m.immediate){const e=y._asyncData[f.value].execute(v);s()?n(()=>e):y.hook("app:created",async()=>{await e})}const h={data:writableComputedRef(()=>y._asyncData[f.value]?.data),pending:writableComputedRef(()=>y._asyncData[f.value]?.pending),status:writableComputedRef(()=>y._asyncData[f.value]?.status),error:writableComputedRef(()=>y._asyncData[f.value]?.error),refresh:(...e)=>y._asyncData[f.value].execute(...e),execute:(...e)=>y._asyncData[f.value].execute(...e),clear:()=>clearNuxtDataByKey(y,f.value)},D=Promise.resolve(y._asyncDataPromises[f.value]).then(()=>h);return Object.assign(D,h),D}function writableComputedRef(e){return a({get:()=>e()?.value,set(a){const t=e();t&&(t.value=a)}})}function clearNuxtDataByKey(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=void 0),e._asyncData[a]&&(e._asyncData[a].data.value=l(e._asyncData[a]._default()),e._asyncData[a].error.value=void 0,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}e({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(e,{slots:a,attrs:n}){const r=i(!1),o=s();return o&&(o._nuxtClientOnly=!0),p(N,!0),()=>{if(r.value){const e=a.default?.();return e&&1===e.length?[m(e[0],n)]:e}const s=a.fallback||a.placeholder;if(s)return t(s);const o=e.fallback||e.placeholder||"",i=e.fallbackTag||e.placeholderTag||"span";return d(i,n,o)}}});const getDefault=()=>{},getDefaultCachedData=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0,S=e({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:a}){_();const r=D().icon,s=useResolvedName(()=>e.name),o="i-"+s.value;return s.value&&n(async()=>{await useAsyncData(o,async()=>await loadIcon(s.value,r.fetchTimeout),{deep:!1})}),()=>t(f,{icon:s.value,ssr:!0,customise:resolveCustomizeFn(e.customize,r.customize)},a)}}),T=e({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:n}){const r=_(),s=D().icon,o=useResolvedName(()=>e.name),i=a(()=>r.vueApp?.component(o.value)||("svg"===(e.mode||s.mode)?S:z)),u=a(()=>{const a=e.size||s.size;return a?{fontSize:Number.isNaN(+a)?a:a+"px"}:null});return()=>t(i.value,{...s.attrs,name:o.value,class:s.class,style:u.value,customize:e.customize},n)}});export{T as default};
//# sourceMappingURL=index-D4P2202X.mjs.map
